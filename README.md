# Binary Tree Leaf Remover

## Введение
Эта программа реализует приложение на Java с использованием библиотеки Swing для работы с двоичным деревом. Основная задача — удаление всех листьев, не находящихся на самом нижнем уровне дерева. Дерево вводится в скобочной нотации, отображается графически и в текстовом формате, соответствующем требованиям задачи. Проект структурирован для максимальной понятности, модульности и удобства использования.

## Теория

### Двоичные деревья
Двоичное дерево — это иерархическая структура данных, в которой каждый узел имеет не более двух потомков (левый и правый). Основные понятия:
- **Узел**: Элемент дерева, содержащий значение и ссылки на левое и правое поддерево.
- **Корень**: Верхний узел дерева.
- **Лист**: Узел, у которого нет потомков (левый и правый дочерние узлы равны `null`).
- **Глубина узла**: Количество уровней от корня до данного узла (корень имеет глубину 1).
- **Максимальная глубина дерева**: Длина самого длинного пути от корня до листа.

### Скобочная нотация
Скобочная нотация — это способ представления дерева в виде строки, где:
- Каждый узел записывается как `(значение (левое_поддерево)(правое_поддерево))`.
- Если поддерево отсутствует, оно обозначается пустыми скобками `()` или пропускается.
- Пример: `(1(2)(3))` описывает дерево с корнем 1, левым ребенком 2 (лист) и правым ребенком 3 (лист).

### Задача: Удаление листьев
Задача требует удалить все листья, которые не находятся на максимальной глубине дерева. Лист — это узел, у которого нет дочерних узлов. Алгоритм должен:
1. Найти максимальную глубину дерева.
2. Удалить все листья, находящиеся на глубине меньше максимальной.
3. Сохранить структуру дерева, обновляя ссылки на оставшиеся узлы.

### Требования к реализации
- Реализация дерева через класс `BinaryTree<T>` с внутренним классом узла `Node`.
- Поддержка ввода дерева в скобочной нотации.
- Вывод дерева в текстовом формате (A, AB1, AB2, ...) и графическое отображение.
- Возможность расширения для деревьев с произвольным числом потомков (хотя задача требует двоичное дерево).

## Структура проекта
Проект разделен на несколько файлов для модульности:
- **BinaryTreeApp.java**: Главный класс, реализующий пользовательский интерфейс (Swing).
- **BinaryTree.java**: Класс двоичного дерева, содержащий логику работы с деревом и метод удаления листьев.
- **TreePanel.java**: Класс для графической отрисовки дерева.
- **TreeParser.java**: Класс для парсинга скобочной нотации.
- **README.md**: Документация проекта.

## Подробное объяснение кода

### BinaryTree.java
Этот файл содержит реализацию двоичного дерева и основную логику задачи.

#### Класс `BinaryTree<T>`
- **Обобщения**: Использует параметр типа `T extends Comparable<T>` для поддержки любых сравниваемых типов данных. В данном проекте используется `Integer`.
- **Поля**:
  - `private Node root`: Корень дерева.
- **Внутренний класс `Node`**:
  - Поля: `T value` (значение узла), `Node left` (левый ребенок), `Node right` (правый ребенок).
  - Конструктор: `Node(T value)` инициализирует узел с заданным значением.

#### Метод `buildFromString`
- **Назначение**: Строит дерево из строки в скобочной нотации.
- **Реализация**: Делегирует парсинг классу `TreeParser`, передавая текущий экземпляр `BinaryTree` для создания узлов правильного типа.
- **Код**:
  ```java
  public void buildFromString(String input) {
      root = TreeParser.parse(input, this);
  }
  ```

#### Метод `removeNonLowestLeaves`
- **Назначение**: Удаляет все листья, не находящиеся на максимальной глубине.
- **Алгоритм**:
  1. Находит максимальную глубину дерева с помощью `findMaxDepth`.
  2. Рекурсивно обходит дерево, удаляя листья на глубине меньше максимальной.
  3. Проверяет, не стал ли узел листом после обработки его детей, и удаляет его, если он не на максимальной глубине.
- **Код**:
  ```java
  public void removeNonLowestLeaves() {
      if (root == null) return;
      int maxDepth = findMaxDepth(root);
      root = removeNonLowestLeaves(root, 1, maxDepth);
  }

  private int findMaxDepth(Node node) {
      if (node == null) return 0;
      return 1 + Math.max(findMaxDepth(node.left), findMaxDepth(node.right));
  }

  private Node removeNonLowestLeaves(Node node, int currentDepth, int maxDepth) {
      if (node == null) return null;
      if (node.left == null && node.right == null && currentDepth < maxDepth) {
          return null;
      }
      node.left = removeNonLowestLeaves(node.left, currentDepth + 1, maxDepth);
      node.right = removeNonLowestLeaves(node.right, currentDepth + 1, maxDepth);
      if (node.left == null && node.right == null && currentDepth < maxDepth) {
          return null;
      }
      return node;
  }
  ```
- **Объяснение**:
  - `findMaxDepth`: Рекурсивно вычисляет максимальную глубину, возвращая 0 для `null`-узлов и 1 + максимум глубин левого и правого поддерева.
  - `removeNonLowestLeaves`:
    - Проверяет, является ли текущий узел листом (`left == null && right == null`) и находится ли он на глубине меньше максимальной (`currentDepth < maxDepth`). Если да, узел удаляется (`return null`).
    - Рекурсивно обрабатывает левое и правое поддерево.
    - После обработки детей проверяет, не стал ли узел листом (например, если его дети были удалены). Если он стал листом и не на максимальной глубине, он тоже удаляется.
  - Этот метод гарантирует, что все листья, не на максимальной глубине, удаляются, включая те, которые стали листьями в процессе обработки.

#### Метод `printTree`
- **Назначение**: Формирует текстовое представление дерева в формате A, AB1, AB2, ...
- **Код**:
  ```java
  public String printTree() {
      StringBuilder sb = new StringBuilder();
      printTree(root, "", sb);
      return sb.toString();
  }

  private void printTree(Node node, String prefix, StringBuilder sb) {
      if (node == null) return;
      sb.append(prefix).append(node.value).append("\n");
      printTree(node.left, prefix + node.value, sb);
      printTree(node.right, prefix + node.value, sb);
  }
  ```
- **Объяснение**:
  - Рекурсивно обходит дерево, добавляя значение узла к префиксу.
  - Для каждого узла формирует строку вида `prefix + node.value`.
  - Обрабатывает левое и правое поддерево с обновленным префиксом.
  - Формат соответствует требованиям: корень (A), затем пути к узлам (AB1, AB2, ...).

#### Метод `createNode`
- **Назначение**: Создает узел для использования в `TreeParser`.
- **Код**:
  ```java
  public Node createNode(T value) {
      return new Node(value);
  }
  ```

### TreeParser.java
- **Назначение**: Парсит строку в скобочной нотации и строит дерево.
- **Ключевой метод**:
  ```java
  public static <T extends Comparable<T>> BinaryTree<T>.Node parse(String input, BinaryTree<T> tree) {
      if (input == null || input.isEmpty()) {
          return null;
      }
      return parseNode(input, new int[]{0}, tree);
  }
  ```
- **Объяснение**:
  - Использует массив `index` для отслеживания текущей позиции в строке.
  - Пропускает открывающую скобку `(`.
  - Читает числовое значение узла.
  - Создает узел через `tree.createNode`.
  - Рекурсивно парсит левое и правое поддерево.
  - Пропускает закрывающую скобку `)`.
  - Обрабатывает ошибки ввода, выбрасывая исключения.

### TreePanel.java
- **Назначение**: Графически отображает дерево.
- **Ключевой метод**:
  ```java
  protected void paintComponent(Graphics g) {
      super.paintComponent(g);
      if (tree != null && tree.getRoot() != null) {
          drawTree(g, tree.getRoot(), getWidth() / 2, 50, getWidth() / 4, 50);
      }
  }
  ```
- **Объяснение**:
  - Рисует узлы как синие круги с белым текстом (значение узла).
  - Соединяет узлы черными линиями.
  - Рекурсивно отрисовывает левое и правое поддерево, уменьшая горизонтальное смещение (`xOffset`) для каждого уровня.

### BinaryTreeApp.java
- **Назначение**: Главный класс, реализующий Swing-интерфейс.
- **Основные компоненты**:
  - **Панель управления**: Текстовое поле для ввода скобочной нотации и кнопки "Build Tree" и "Remove Non-Lowest Leaves".
  - **Графическая панель**: Отображает дерево с помощью `TreePanel`.
  - **Текстовое поле**: Показывает текстовое представление дерева.
- **Обработчики событий**:
  - "Build Tree": Парсит ввод и строит дерево.
  - "Remove Non-Lowest Leaves": Выполняет удаление листьев и обновляет отображение.



4. **Использование**:
   - Введите дерево в скобочной нотации в текстовое поле (например, `(1(2(4))(3))`).
   - Нажмите "Build Tree" — дерево отобразится графически и в текстовом формате.
   - Нажмите "Remove Non-Lowest Leaves" — программа удалит листья, не на максимальной глубине, и обновит отображение.

## Примеры для проверки
Ниже приведены три примера деревьев, где гарантированно происходит удаление листьев, так как в каждом есть листья на глубине меньше максимальной.

### Пример 1: Простое дерево с листом на меньшей глубине
**Ввод**:
```
(1(2(4))(3))
```

### Пример 2: Несбалансированное дерево
**Ввод**:
```
(1(2(4(8))(5))(3))
```

### Пример 3: Сложное дерево с листьями на разных уровнях
**Ввод**:
```
(1(2(4(7)(8))(5))(3(6(9))))
```
